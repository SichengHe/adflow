!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module initializeflow_b
  use constants, only : inttype, realtype, maxstringlen
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------
  save 

contains
!  differentiation of referencestate in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: mach veldirfreestream machcoef
!                tinfdim pinf timeref rhoinf muref rhoinfdim tref
!                winf muinf uinf pinfcorr rgas pinfdim pref rhoref
!   with respect to varying inputs: mach veldirfreestream machcoef
!                tinfdim pinf timeref rhoinf muref rhoinfdim tref
!                winf muinf uinf pinfcorr rgas pinfdim pref rhoref
!   rw status of diff variables: mach:incr veldirfreestream:incr
!                machcoef:incr tinfdim:incr pinf:in-zero timeref:in-zero
!                rhoinf:in-zero muref:in-zero rhoinfdim:incr tref:in-zero
!                winf:in-zero muinf:in-zero uinf:in-zero pinfcorr:in-zero
!                rgas:in-zero muinfdim:(loc) pinfdim:incr pref:in-zero
!                rhoref:in-zero
  subroutine referencestate_b()
!
!       the original version has been nuked since the computations are
!       no longer necessary when calling from python
!       this is the most compliclated routine in all of adflow. it is
!       stupidly complicated. this is most likely the reason your
!       derivatives are wrong. you don't understand this routine
!       and its effects.
!       this routine *requries* the following as input:
!       mach, pinfdim, tinfdim, rhoinfdim, rgasdim (machcoef non-sa
!        turbulence only)
!       optionally, pref, rhoref and tref are used if they are
!       are non-negative. this only happens when you want the equations
!       normalized by values other than the freestream
!      * this routine computes as output:
!      *   muinfdim, (unused anywhere in code)
!         pref, rhoref, tref, muref, timeref ('dimensional' reference)
!         pinf, pinfcorr, rhoinf, uinf, rgas, muinf, gammainf and winf
!         (non-dimensionalized values used in actual computations)
!
    use constants
    use paramturb
    use inputphysics, only : equations, mach, machd, machcoef, &
&   machcoefd, musuthdim, tsuthdim, veldirfreestream, veldirfreestreamd,&
&   rgasdim, ssuthdim, eddyvisinfratio, turbmodel, turbintensityinf
    use flowvarrefstate, only : pinfdim, pinfdimd, tinfdim, tinfdimd, &
&   rhoinfdim, rhoinfdimd, muinfdim, muinfdimd, pref, prefd, rhoref, &
&   rhorefd, tref, trefd, muref, murefd, timeref, timerefd, uref, urefd,&
&   href, hrefd, pinf, pinfd, pinfcorr, pinfcorrd, rhoinf, rhoinfd, uinf&
&   , uinfd, rgas, rgasd, muinf, muinfd, gammainf, winf, winfd, nw, nwf,&
&   kpresent, winf, winfd
    use flowutils_b, only : computegamma, etot, etot_b
    use turbutils_b, only : sanuknowneddyratio, sanuknowneddyratio_b
    implicit none
    integer(kind=inttype) :: sps, nn, mm, ierr
    real(kind=realtype) :: gm1, ratio
    real(kind=realtype) :: nuinf, ktmp, uinf2
    real(kind=realtype) :: nuinfd, ktmpd, uinf2d
    real(kind=realtype) :: vinf, zinf, tmp1(1), tmp2(1)
    real(kind=realtype) :: vinfd, zinfd
    intrinsic sqrt
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp3
    real(kind=realtype) :: tmp4
    integer :: branch
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd2
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
    real(kind=realtype) :: temp
! compute the dimensional viscosity from sutherland's law
    muinfdim = musuthdim*((tsuthdim+ssuthdim)/(tinfdim+ssuthdim))*(&
&     tinfdim/tsuthdim)**1.5_realtype
! set the reference values. they *could* be different from the
! free-stream values for an internal flow simulation. for now,
! we just use the actual free stream values.
    pref = pinfdim
    tref = tinfdim
    rhoref = rhoinfdim
! compute the value of muref, such that the nondimensional
! equations are identical to the dimensional ones.
! note that in the non-dimensionalization of muref there is
! a reference length. however this reference length is 1.0
! in this code, because the coordinates are converted to
! meters.
    muref = sqrt(pref*rhoref)
! compute timeref for a correct nondimensionalization of the
! unsteady equations. some story as for the reference viscosity
! concerning the reference length.
! compute the nondimensional pressure, density, velocity,
! viscosity and gas constant.
    pinf = pinfdim/pref
    rhoinf = rhoinfdim/rhoref
    uinf = mach*sqrt(gammainf*pinf/rhoinf)
    muinf = muinfdim/muref
    call computegamma(tmp1, tmp2, 1)
    call pushreal8(gammainf)
    gammainf = tmp2(1)
! ----------------------------------------
!      compute the final winf
! ----------------------------------------
! allocate the memory for winf if necessary
! zero out the winf first
    winf(:) = zero
! set the reference value of the flow variables, except the total
! energy. this will be computed at the end of this routine.
    winf(irho) = rhoinf
    winf(ivx) = uinf*veldirfreestream(1)
    winf(ivy) = uinf*veldirfreestream(2)
    winf(ivz) = uinf*veldirfreestream(3)
! compute the velocity squared based on machcoef. this gives a
! better indication of the 'speed' of the flow so the turubulence
! intensity ration is more meaningful especially for moving
! geometries. (not used in sa model)
    uinf2 = machcoef*machcoef*gammainf*pinf/rhoinf
! set the turbulent variables if transport variables are to be
! solved. we should be checking for rans equations here,
! however, this code is included in block res. the issue is
! that for frozen turbulence (or ank jacobian) we call the
! block_res with equationtype set to laminar even though we are
! actually solving the rans equations. the issue is that, the
! freestream turb variables will be changed to zero, thus
! changing the solution. insteady we check if nw > nwf which
! will accomplish the same thing.
    if (nw .gt. nwf) then
      nuinf = muinf/rhoinf
      select case  (turbmodel) 
      case (spalartallmaras, spalartallmarasedwards) 
        winf(itu1) = sanuknowneddyratio(eddyvisinfratio, nuinf)
        call pushcontrol3b(1)
      case (komegawilcox, komegamodified, mentersst) 
!=============================================================
        winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
        tmp = winf(itu1)/(eddyvisinfratio*nuinf)
        call pushreal8(winf(itu2))
        winf(itu2) = tmp
        call pushcontrol3b(2)
      case (ktau) 
!=============================================================
        winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
        tmp0 = eddyvisinfratio*nuinf/winf(itu1)
        call pushreal8(winf(itu2))
        winf(itu2) = tmp0
        call pushcontrol3b(3)
      case (v2f) 
!=============================================================
        winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
        tmp3 = 0.09_realtype*winf(itu1)**2/(eddyvisinfratio*nuinf)
        call pushreal8(winf(itu2))
        winf(itu2) = tmp3
        tmp4 = 0.666666_realtype*winf(itu1)
        call pushreal8(winf(itu3))
        winf(itu3) = tmp4
        call pushreal8(winf(itu4))
        winf(itu4) = 0.0_realtype
        call pushcontrol3b(4)
      case default
        call pushcontrol3b(0)
      end select
    else
      call pushcontrol3b(5)
    end if
! set the value of pinfcorr. in case a k-equation is present
! add 2/3 times rho*k.
    pinfcorr = pinf
    if (kpresent) then
      pinfcorr = pinf + two*third*rhoinf*winf(itu1)
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
! compute the free stream total energy.
    ktmp = zero
    if (kpresent) then
      ktmp = winf(itu1)
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    vinf = zero
    zinf = zero
    vinfd = 0.0_8
    zinfd = 0.0_8
    ktmpd = 0.0_8
    call etot_b(rhoinf, rhoinfd, uinf, uinfd, vinf, vinfd, zinf, zinfd, &
&         pinfcorr, pinfcorrd, ktmp, ktmpd, winf(irhoe), winfd(irhoe), &
&         kpresent)
    call popcontrol1b(branch)
    if (branch .eq. 0) winfd(itu1) = winfd(itu1) + ktmpd
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      tempd8 = two*third*pinfcorrd
      pinfd = pinfd + pinfcorrd
      rhoinfd = rhoinfd + winf(itu1)*tempd8
      winfd(itu1) = winfd(itu1) + rhoinf*tempd8
      pinfcorrd = 0.0_8
    end if
    pinfd = pinfd + pinfcorrd
    call popcontrol3b(branch)
    if (branch .lt. 3) then
      if (branch .eq. 0) then
        uinf2d = 0.0_8
        nuinfd = 0.0_8
      else if (branch .eq. 1) then
        call sanuknowneddyratio_b(eddyvisinfratio, nuinf, nuinfd, winfd(&
&                           itu1))
        winfd(itu1) = 0.0_8
        uinf2d = 0.0_8
      else
        call popreal8(winf(itu2))
        tmpd = winfd(itu2)
        winfd(itu2) = 0.0_8
        tempd5 = tmpd/(eddyvisinfratio*nuinf)
        winfd(itu1) = winfd(itu1) + tempd5
        nuinfd = -(winf(itu1)*tempd5/nuinf)
        uinf2d = turbintensityinf**2*1.5_realtype*winfd(itu1)
        winfd(itu1) = 0.0_8
      end if
    else if (branch .eq. 3) then
      call popreal8(winf(itu2))
      tmpd0 = winfd(itu2)
      winfd(itu2) = 0.0_8
      tempd6 = eddyvisinfratio*tmpd0/winf(itu1)
      nuinfd = tempd6
      winfd(itu1) = winfd(itu1) - nuinf*tempd6/winf(itu1)
      uinf2d = turbintensityinf**2*1.5_realtype*winfd(itu1)
      winfd(itu1) = 0.0_8
    else if (branch .eq. 4) then
      call popreal8(winf(itu4))
      winfd(itu4) = 0.0_8
      call popreal8(winf(itu3))
      tmpd1 = winfd(itu3)
      winfd(itu3) = 0.0_8
      winfd(itu1) = winfd(itu1) + 0.666666_realtype*tmpd1
      call popreal8(winf(itu2))
      tmpd2 = winfd(itu2)
      winfd(itu2) = 0.0_8
      tempd7 = 0.09_realtype*tmpd2/(eddyvisinfratio*nuinf)
      winfd(itu1) = winfd(itu1) + 2*winf(itu1)*tempd7
      nuinfd = -(winf(itu1)**2*tempd7/nuinf)
      uinf2d = turbintensityinf**2*1.5_realtype*winfd(itu1)
      winfd(itu1) = 0.0_8
    else
      uinf2d = 0.0_8
      goto 100
    end if
    muinfd = muinfd + nuinfd/rhoinf
    rhoinfd = rhoinfd - muinf*nuinfd/rhoinf**2
 100 tempd = machcoef**2*gammainf*uinf2d/rhoinf
    machcoefd = machcoefd + pinf*gammainf*2*machcoef*uinf2d/rhoinf
    uinfd = uinfd + veldirfreestream(3)*winfd(ivz)
    veldirfreestreamd(3) = veldirfreestreamd(3) + uinf*winfd(ivz)
    winfd(ivz) = 0.0_8
    uinfd = uinfd + veldirfreestream(2)*winfd(ivy)
    veldirfreestreamd(2) = veldirfreestreamd(2) + uinf*winfd(ivy)
    winfd(ivy) = 0.0_8
    uinfd = uinfd + veldirfreestream(1)*winfd(ivx)
    veldirfreestreamd(1) = veldirfreestreamd(1) + uinf*winfd(ivx)
    winfd(ivx) = 0.0_8
    call popreal8(gammainf)
    muinfdimd = muinfd/muref
    murefd = murefd - muinfdim*muinfd/muref**2
    tempd1 = rgasdim*rgasd/pref
    trefd = trefd + rhoref*tempd1
    temp0 = gammainf*pinf/rhoinf
    temp = sqrt(temp0)
    if (temp0 .eq. 0.0_8) then
      tempd0 = 0.0
    else
      tempd0 = gammainf*mach*uinfd/(2.0*temp*rhoinf)
    end if
    pinfd = pinfd + tempd0 + tempd
    rhoinfd = rhoinfd + winfd(irho) - pinf*tempd0/rhoinf - pinf*tempd/&
&     rhoinf
    machd = machd + temp*uinfd
    if (rhoref/pref .eq. 0.0_8) then
      tempd3 = 0.0
    else
      tempd3 = timerefd/(2.0*sqrt(rhoref/pref)*pref)
    end if
    if (pref*rhoref .eq. 0.0_8) then
      tempd2 = 0.0
    else
      tempd2 = murefd/(2.0*sqrt(pref*rhoref))
    end if
    rhorefd = rhorefd + pref*tempd2 - rhoinfdim*rhoinfd/rhoref**2 + &
&     tempd3 + tref*tempd1
    prefd = prefd + rhoref*tempd2 - pinfdim*pinfd/pref**2 - rhoref*&
&     tempd3/pref - rhoref*tref*tempd1/pref
    rhoinfdimd = rhoinfdimd + rhorefd + rhoinfd/rhoref
    pinfdimd = pinfdimd + prefd + pinfd/pref
    tempd4 = musuthdim*(tsuthdim+ssuthdim)*muinfdimd/(ssuthdim+tinfdim)
    tinfdimd = tinfdimd + (1.5_realtype*(tinfdim/tsuthdim)**0.5/tsuthdim&
&     -(tinfdim/tsuthdim)**1.5_realtype/(ssuthdim+tinfdim))*tempd4 + &
&     trefd
    pinfd = 0.0_8
    timerefd = 0.0_8
    rhoinfd = 0.0_8
    murefd = 0.0_8
    trefd = 0.0_8
    winfd = 0.0_8
    muinfd = 0.0_8
    uinfd = 0.0_8
    pinfcorrd = 0.0_8
    rgasd = 0.0_8
    prefd = 0.0_8
    rhorefd = 0.0_8
  end subroutine referencestate_b
  subroutine referencestate()
!
!       the original version has been nuked since the computations are
!       no longer necessary when calling from python
!       this is the most compliclated routine in all of adflow. it is
!       stupidly complicated. this is most likely the reason your
!       derivatives are wrong. you don't understand this routine
!       and its effects.
!       this routine *requries* the following as input:
!       mach, pinfdim, tinfdim, rhoinfdim, rgasdim (machcoef non-sa
!        turbulence only)
!       optionally, pref, rhoref and tref are used if they are
!       are non-negative. this only happens when you want the equations
!       normalized by values other than the freestream
!      * this routine computes as output:
!      *   muinfdim, (unused anywhere in code)
!         pref, rhoref, tref, muref, timeref ('dimensional' reference)
!         pinf, pinfcorr, rhoinf, uinf, rgas, muinf, gammainf and winf
!         (non-dimensionalized values used in actual computations)
!
    use constants
    use paramturb
    use inputphysics, only : equations, mach, machcoef, musuthdim, &
&   tsuthdim, veldirfreestream, rgasdim, ssuthdim, eddyvisinfratio, &
&   turbmodel, turbintensityinf
    use flowvarrefstate, only : pinfdim, tinfdim, rhoinfdim, muinfdim,&
&   pref, rhoref, tref, muref, timeref, uref, href, pinf, pinfcorr, &
&   rhoinf, uinf, rgas, muinf, gammainf, winf, nw, nwf, kpresent, winf
    use flowutils_b, only : computegamma, etot
    use turbutils_b, only : sanuknowneddyratio
    implicit none
    integer(kind=inttype) :: sps, nn, mm, ierr
    real(kind=realtype) :: gm1, ratio
    real(kind=realtype) :: nuinf, ktmp, uinf2
    real(kind=realtype) :: vinf, zinf, tmp1(1), tmp2(1)
    intrinsic sqrt
! compute the dimensional viscosity from sutherland's law
    muinfdim = musuthdim*((tsuthdim+ssuthdim)/(tinfdim+ssuthdim))*(&
&     tinfdim/tsuthdim)**1.5_realtype
! set the reference values. they *could* be different from the
! free-stream values for an internal flow simulation. for now,
! we just use the actual free stream values.
    pref = pinfdim
    tref = tinfdim
    rhoref = rhoinfdim
! compute the value of muref, such that the nondimensional
! equations are identical to the dimensional ones.
! note that in the non-dimensionalization of muref there is
! a reference length. however this reference length is 1.0
! in this code, because the coordinates are converted to
! meters.
    muref = sqrt(pref*rhoref)
! compute timeref for a correct nondimensionalization of the
! unsteady equations. some story as for the reference viscosity
! concerning the reference length.
    timeref = sqrt(rhoref/pref)
    href = pref/rhoref
    uref = sqrt(href)
! compute the nondimensional pressure, density, velocity,
! viscosity and gas constant.
    pinf = pinfdim/pref
    rhoinf = rhoinfdim/rhoref
    uinf = mach*sqrt(gammainf*pinf/rhoinf)
    rgas = rgasdim*rhoref*tref/pref
    muinf = muinfdim/muref
    tmp1(1) = tinfdim
    call computegamma(tmp1, tmp2, 1)
    gammainf = tmp2(1)
! ----------------------------------------
!      compute the final winf
! ----------------------------------------
! allocate the memory for winf if necessary
! zero out the winf first
    winf(:) = zero
! set the reference value of the flow variables, except the total
! energy. this will be computed at the end of this routine.
    winf(irho) = rhoinf
    winf(ivx) = uinf*veldirfreestream(1)
    winf(ivy) = uinf*veldirfreestream(2)
    winf(ivz) = uinf*veldirfreestream(3)
! compute the velocity squared based on machcoef. this gives a
! better indication of the 'speed' of the flow so the turubulence
! intensity ration is more meaningful especially for moving
! geometries. (not used in sa model)
    uinf2 = machcoef*machcoef*gammainf*pinf/rhoinf
! set the turbulent variables if transport variables are to be
! solved. we should be checking for rans equations here,
! however, this code is included in block res. the issue is
! that for frozen turbulence (or ank jacobian) we call the
! block_res with equationtype set to laminar even though we are
! actually solving the rans equations. the issue is that, the
! freestream turb variables will be changed to zero, thus
! changing the solution. insteady we check if nw > nwf which
! will accomplish the same thing.
    if (nw .gt. nwf) then
      nuinf = muinf/rhoinf
      select case  (turbmodel) 
      case (spalartallmaras, spalartallmarasedwards) 
        winf(itu1) = sanuknowneddyratio(eddyvisinfratio, nuinf)
      case (komegawilcox, komegamodified, mentersst) 
!=============================================================
        winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
        winf(itu2) = winf(itu1)/(eddyvisinfratio*nuinf)
      case (ktau) 
!=============================================================
        winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
        winf(itu2) = eddyvisinfratio*nuinf/winf(itu1)
      case (v2f) 
!=============================================================
        winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
        winf(itu2) = 0.09_realtype*winf(itu1)**2/(eddyvisinfratio*nuinf)
        winf(itu3) = 0.666666_realtype*winf(itu1)
        winf(itu4) = 0.0_realtype
      end select
    end if
! set the value of pinfcorr. in case a k-equation is present
! add 2/3 times rho*k.
    pinfcorr = pinf
    if (kpresent) pinfcorr = pinf + two*third*rhoinf*winf(itu1)
! compute the free stream total energy.
    ktmp = zero
    if (kpresent) ktmp = winf(itu1)
    vinf = zero
    zinf = zero
    call etot(rhoinf, uinf, vinf, zinf, pinfcorr, ktmp, winf(irhoe), &
&       kpresent)
  end subroutine referencestate
!  differentiation of timespectralmatrices in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *diagmatcoefspectral *dvector
!                *dscalar *coefspectral *matrixcoefspectral
!   with respect to varying inputs: *diagmatcoefspectral *dvector
!                *dscalar *coefspectral *matrixcoefspectral
!   rw status of diff variables: *sections.timeperiod:(loc) *diagmatcoefspectral:in-out
!                *dvector:in-out *dscalar:in-out *coefspectral:in-out
!                *matrixcoefspectral:in-out (global)timeref:(loc)
!   plus diff mem management of: sections:in diagmatcoefspectral:in
!                dvector:in dscalar:in coefspectral:in matrixcoefspectral:in
  subroutine timespectralmatrices_b()
!
!       timespectralmatrices computes the matrices for the time
!       derivative of the time spectral method for all sections. for
!       scalar quantities these matrices only differ if sections have
!       different periodic times. for vector quantities, such as
!       momentum, these matrices can be different depending on whether
!       the section is rotating or not and the number of slices
!       present.
!
    use constants
    use inputphysics, only : equationmode
    use inputtimespectral, only : ntimeintervalsspectral, &
&   rotmatrixspectral, coefspectral, coefspectrald, matrixcoefspectral, &
&   matrixcoefspectrald, diagmatcoefspectral, diagmatcoefspectrald, &
&   dscalar, dscalard, dvector, dvectord
    use section, only : nsections
    use utils_b, only : terminate
    implicit none
!
!      local variables.
!
    integer :: ierr
    integer(kind=inttype) :: nn, mm, ll, kk, ii
    integer(kind=inttype) :: i, j
    real(kind=realtype), dimension(3, 3) :: tmpmat
    real(kind=realtype), dimension(3, 3) :: tmpmatd
    integer :: branch
! this routine is only used for the spectral solutions. return
! immediately if a different mode is solved.
    if (equationmode .eq. timespectral) then
!
!       determine the time derivative matrices for the sections.
!
! loop over the number of sections.
sectionloop:do ii=1,nsections
!
!         matrix for scalar quantities.
!
! loop over the number of rows.
        do nn=1,ntimeintervalsspectral
! loop over the rest of the columns.
          do mm=1,ntimeintervalsspectral-1
! determine the corresponding column index.
            call pushinteger4(ll)
            ll = nn + mm
            if (ll .gt. ntimeintervalsspectral) ll = ll - &
&               ntimeintervalsspectral
          end do
        end do
!
!         matrices for vector quantities.
!
! loop over the number of time intervals; the number of rows
! is 3 times this number.
rowloop:do nn=1,ntimeintervalsspectral
! initialize the diagonal block to diagmatcoefspectral,
! the additional diagonal entry needed for the rotational
! periodicity.
          call pushinteger4(kk)
          kk = 3*(nn-1)
! loop over the other time intervals, which contribute to
! the time derivative.
columnloop:do mm=1,ntimeintervalsspectral-1
! determine the corresponding column index and check the
! situation we are having here.
            call pushinteger4(ll)
            ll = nn + mm
            if (ll .gt. ntimeintervalsspectral) then
! index is outside the range and a shift must be applied.
              ll = ll - ntimeintervalsspectral
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
            end if
! determine the offset for the column index and store
! this submatrix in the correct place of dvector.
            ll = 3*(ll-1)
          end do columnloop
        end do rowloop
      end do sectionloop
      tmpmatd = 0.0_8
      do ii=nsections,1,-1
        do nn=ntimeintervalsspectral,1,-1
          do mm=ntimeintervalsspectral-1,1,-1
            do j=3,1,-1
              do i=3,1,-1
                tmpmatd(i, j) = tmpmatd(i, j) + dvectord(ii, kk+i, ll+j)
                dvectord(ii, kk+i, ll+j) = 0.0_8
              end do
            end do
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              do j=3,1,-1
                do i=3,1,-1
                  matrixcoefspectrald(ii, mm, i, 1) = &
&                   matrixcoefspectrald(ii, mm, i, 1) + &
&                   rotmatrixspectral(ii, 1, j)*tmpmatd(i, j)
                  matrixcoefspectrald(ii, mm, i, 2) = &
&                   matrixcoefspectrald(ii, mm, i, 2) + &
&                   rotmatrixspectral(ii, 2, j)*tmpmatd(i, j)
                  matrixcoefspectrald(ii, mm, i, 3) = &
&                   matrixcoefspectrald(ii, mm, i, 3) + &
&                   rotmatrixspectral(ii, 3, j)*tmpmatd(i, j)
                  tmpmatd(i, j) = 0.0_8
                end do
              end do
            else
              do j=3,1,-1
                do i=3,1,-1
                  matrixcoefspectrald(ii, mm, i, j) = &
&                   matrixcoefspectrald(ii, mm, i, j) + tmpmatd(i, j)
                  tmpmatd(i, j) = 0.0_8
                end do
              end do
            end if
            call popinteger4(ll)
          end do
          do j=3,1,-1
            do i=3,1,-1
              diagmatcoefspectrald(ii, i, j) = diagmatcoefspectrald(ii, &
&               i, j) + dvectord(ii, kk+i, kk+j)
              dvectord(ii, kk+i, kk+j) = 0.0_8
            end do
          end do
          call popinteger4(kk)
        end do
        do nn=ntimeintervalsspectral,1,-1
          do mm=ntimeintervalsspectral-1,1,-1
            coefspectrald(ii, mm) = coefspectrald(ii, mm) + dscalard(ii&
&             , nn, ll)
            dscalard(ii, nn, ll) = 0.0_8
            call popinteger4(ll)
          end do
          dscalard(ii, nn, nn) = 0.0_8
        end do
      end do
      call timespectralcoef_b()
    end if
  end subroutine timespectralmatrices_b
!  differentiation of timespectralcoef in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: timeref *sections.timeperiod
!                *diagmatcoefspectral *coefspectral *matrixcoefspectral
!   with respect to varying inputs: timeref *sections.timeperiod
!                *diagmatcoefspectral *coefspectral *matrixcoefspectral
!   rw status of diff variables: timeref:incr *sections.timeperiod:incr
!                *diagmatcoefspectral:in-out *coefspectral:in-out
!                *matrixcoefspectral:in-out
!   plus diff mem management of: sections:in diagmatcoefspectral:in
!                coefspectral:in matrixcoefspectral:in
  subroutine timespectralcoef_b()
!
!       timespectralcoef computes the time integration coefficients
!       for the time spectral method. as it is possible that sections
!       have different periodic times these coefficients are
!       determined for all the sections. for vector quantities, such
!       as momentum, these coefficients can also be different due to
!       rotation and the fact that only a part of the wheel is
!       simulated.
!
    use constants
    use flowvarrefstate, only : timeref, timerefd
    use inputtimespectral, only : ntimeintervalsspectral, &
&   rotmatrixspectral, coefspectral, coefspectrald, matrixcoefspectral, &
&   matrixcoefspectrald, diagmatcoefspectral, diagmatcoefspectrald
    use section, only : nsections, sections, sectionsd
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: pp, nn, mm, ii, i, j, ntot
    real(kind=realtype) :: coef, dangle, angle, fact, slicesfact
    real(kind=realtype) :: coefd
    real(kind=realtype), dimension(3, 3) :: rotmat, tmp
    intrinsic real
    intrinsic sin
    intrinsic mod
    intrinsic cos
    integer :: branch
    integer :: ad_to
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd0
! loop over the number of sections.
sectionloop:do mm=1,nsections
! initialize dangle (smallest angle in the cotangent function)
! and coef, which is the multiplication factor in front of the
! cotangent/cosecant function. coef is a combination of the 1/2
! and the 2*pi/timeperiod
      dangle = pi/real(ntimeintervalsspectral, realtype)
! computation of the scalar coefficients.
scalarloop:do nn=1,ntimeintervalsspectral-1
        call pushreal8(angle)
        angle = nn*dangle
! the coefficient for an odd and even number of time
! instances are different; the former is 1/sin, the
! latter cos/sin or 1/tan.
        if (mod(ntimeintervalsspectral, 2_inttype) .eq. 0) then
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
      end do scalarloop
! initialize dangle to the smallest angle in the cotangent
! or cosecant function. now this angle is for the entire wheel,
! i.e. the number of slices must be taken into account.
      ntot = ntimeintervalsspectral*sections(mm)%nslices
      dangle = pi/real(ntot, realtype)
! initialize the rotation matrix to the unity matrix.
      rotmat(1, 1) = one
      rotmat(1, 2) = zero
      rotmat(1, 3) = zero
      rotmat(2, 1) = zero
      rotmat(2, 2) = one
      rotmat(2, 3) = zero
      rotmat(3, 1) = zero
      rotmat(3, 2) = zero
      rotmat(3, 3) = one
! loop over the number of spectral coefficient to initialize the
! matrix coefficients; this is basically pp == 0 in the loop
! over the number slices. use is made of the fact that the
! rotation matrix is the identity for pp == 0.
! coef changes sign at every time instance
      slicesfact = one/real(sections(mm)%nslices, realtype)
      fact = one
      do nn=1,ntimeintervalsspectral-1
! determine the scalar coefficient. this value depends now
! whether the total number of time instances in the wheel is
! odd or even.
        call pushreal8(angle)
        angle = nn*dangle
        call pushreal8(coef)
        coef = one/sin(angle)
        if (mod(ntot, 2_inttype) .eq. 0) coef = coef*cos(angle)
        coef = coef*fact*slicesfact
! the first part of matrixcoefspectral is a diagonal matrix,
! because this indicates the contribution of the current
! slice to the time derivative.
        call pushreal8(matrixcoefspectral(mm, nn, 1, 1))
        matrixcoefspectral(mm, nn, 1, 1) = coef
        call pushreal8(matrixcoefspectral(mm, nn, 1, 2))
        matrixcoefspectral(mm, nn, 1, 2) = zero
        call pushreal8(matrixcoefspectral(mm, nn, 1, 3))
        matrixcoefspectral(mm, nn, 1, 3) = zero
        call pushreal8(matrixcoefspectral(mm, nn, 2, 1))
        matrixcoefspectral(mm, nn, 2, 1) = zero
        call pushreal8(matrixcoefspectral(mm, nn, 2, 2))
        matrixcoefspectral(mm, nn, 2, 2) = coef
        call pushreal8(matrixcoefspectral(mm, nn, 2, 3))
        matrixcoefspectral(mm, nn, 2, 3) = zero
        call pushreal8(matrixcoefspectral(mm, nn, 3, 1))
        matrixcoefspectral(mm, nn, 3, 1) = zero
        call pushreal8(matrixcoefspectral(mm, nn, 3, 2))
        matrixcoefspectral(mm, nn, 3, 2) = zero
        call pushreal8(matrixcoefspectral(mm, nn, 3, 3))
        matrixcoefspectral(mm, nn, 3, 3) = coef
        fact = -fact
      end do
! initialize diagmatcoefspectral to zero, because the
! starting index in the loop over the number of slices -1 is
! 1, i.e. the slice where the actual computation takes places
! does not contribute to diagmatcoefspectral.
      do j=1,3
        do i=1,3
          call pushreal8(diagmatcoefspectral(mm, i, j))
          diagmatcoefspectral(mm, i, j) = zero
        end do
      end do
! loop over the additional slices which complete an entire
! revolution. to be able to compute the coefficients a bit
! easier the loop runs from 1 to nslices-1 and not from
! 2 to nslices.
slicesloop:do pp=1,sections(mm)%nslices-1
! compute the rotation matrix for this slice. this is the
! old one multiplied by the transformation matrix going from
! one slices to the next. use tmp as temporary storage.
        do j=1,3
          do i=1,3
            tmp(i, j) = rotmatrixspectral(mm, i, 1)*rotmat(1, j) + &
&             rotmatrixspectral(mm, i, 2)*rotmat(2, j) + &
&             rotmatrixspectral(mm, i, 3)*rotmat(3, j)
          end do
        end do
        rotmat = tmp
        slicesfact = one/real(sections(mm)%nslices, realtype)
! loop over the number of spectral coefficients and update
! matrixcoefspectral. the multiplication with (-1)**nn
! takes place here too.
! multiply also by the term (-1)**(pn+1)
        fact = one
        if (mod(pp*ntimeintervalsspectral, 2_inttype) .ne. 0) fact = -&
&           one
        slicesfact = fact*slicesfact
        fact = one
        ii = pp*ntimeintervalsspectral
        do nn=1,ntimeintervalsspectral-1
! compute the coefficient multiplying the rotation matrix.
! again make a distinction between an odd and an even
! number of time instances for the entire wheel.
          call pushreal8(angle)
          angle = (nn+ii)*dangle
          call pushreal8(coef)
          coef = one/sin(angle)
          if (mod(ntot, 2_inttype) .eq. 0) coef = coef*cos(angle)
          coef = coef*fact*slicesfact
! update matrixcoefspectral.
          do j=1,3
            do i=1,3
              call pushreal8(matrixcoefspectral(mm, nn, i, j))
              matrixcoefspectral(mm, nn, i, j) = matrixcoefspectral(mm, &
&               nn, i, j) + coef*rotmat(i, j)
            end do
          end do
          fact = -fact
        end do
! update diagmatcoefspectral. also here the distinction
! between odd and even number of time instances.
        call pushreal8(angle)
        angle = ii*dangle
        call pushreal8(coef)
        coef = one/sin(angle)
        if (mod(ntot, 2_inttype) .eq. 0) coef = coef*cos(angle)
        coef = coef*slicesfact
        do j=1,3
          do i=1,3
            call pushreal8(diagmatcoefspectral(mm, i, j))
            diagmatcoefspectral(mm, i, j) = diagmatcoefspectral(mm, i, j&
&             ) - coef*rotmat(i, j)
          end do
        end do
      end do slicesloop
      call pushinteger4(pp - 1)
! the matrix coefficients must be multiplied by the leading
! coefficient, which depends on the actual periodic time.
      call pushreal8(coef)
      coef = pi*timeref/sections(mm)%timeperiod
      do j=1,3
        do i=1,3
          call pushreal8(diagmatcoefspectral(mm, i, j))
          diagmatcoefspectral(mm, i, j) = coef*diagmatcoefspectral(mm, i&
&           , j)
        end do
      end do
      do nn=1,ntimeintervalsspectral-1
        do j=1,3
          do i=1,3
            call pushreal8(matrixcoefspectral(mm, nn, i, j))
            matrixcoefspectral(mm, nn, i, j) = coef*matrixcoefspectral(&
&             mm, nn, i, j)
          end do
        end do
      end do
    end do sectionloop
    do mm=nsections,1,-1
      coefd = 0.0_8
      do nn=ntimeintervalsspectral-1,1,-1
        do j=3,1,-1
          do i=3,1,-1
            call popreal8(matrixcoefspectral(mm, nn, i, j))
            coefd = coefd + matrixcoefspectral(mm, nn, i, j)*&
&             matrixcoefspectrald(mm, nn, i, j)
            matrixcoefspectrald(mm, nn, i, j) = coef*matrixcoefspectrald&
&             (mm, nn, i, j)
          end do
        end do
      end do
      do j=3,1,-1
        do i=3,1,-1
          call popreal8(diagmatcoefspectral(mm, i, j))
          coefd = coefd + diagmatcoefspectral(mm, i, j)*&
&           diagmatcoefspectrald(mm, i, j)
          diagmatcoefspectrald(mm, i, j) = coef*diagmatcoefspectrald(mm&
&           , i, j)
        end do
      end do
      call popreal8(coef)
      tempd0 = pi*coefd/sections(mm)%timeperiod
      timerefd = timerefd + tempd0
      sectionsd(mm)%timeperiod = sectionsd(mm)%timeperiod - timeref*&
&       tempd0/sections(mm)%timeperiod
      call popinteger4(ad_to)
      do pp=ad_to,1,-1
        do j=3,1,-1
          do i=3,1,-1
            call popreal8(diagmatcoefspectral(mm, i, j))
          end do
        end do
        call popreal8(coef)
        call popreal8(angle)
        do nn=ntimeintervalsspectral-1,1,-1
          do j=3,1,-1
            do i=3,1,-1
              call popreal8(matrixcoefspectral(mm, nn, i, j))
            end do
          end do
          call popreal8(coef)
          call popreal8(angle)
        end do
      end do
      do j=3,1,-1
        do i=3,1,-1
          call popreal8(diagmatcoefspectral(mm, i, j))
          diagmatcoefspectrald(mm, i, j) = 0.0_8
        end do
      end do
      do nn=ntimeintervalsspectral-1,1,-1
        call popreal8(matrixcoefspectral(mm, nn, 3, 3))
        matrixcoefspectrald(mm, nn, 3, 3) = 0.0_8
        call popreal8(matrixcoefspectral(mm, nn, 3, 2))
        matrixcoefspectrald(mm, nn, 3, 2) = 0.0_8
        call popreal8(matrixcoefspectral(mm, nn, 3, 1))
        matrixcoefspectrald(mm, nn, 3, 1) = 0.0_8
        call popreal8(matrixcoefspectral(mm, nn, 2, 3))
        matrixcoefspectrald(mm, nn, 2, 3) = 0.0_8
        call popreal8(matrixcoefspectral(mm, nn, 2, 2))
        matrixcoefspectrald(mm, nn, 2, 2) = 0.0_8
        call popreal8(matrixcoefspectral(mm, nn, 2, 1))
        matrixcoefspectrald(mm, nn, 2, 1) = 0.0_8
        call popreal8(matrixcoefspectral(mm, nn, 1, 3))
        matrixcoefspectrald(mm, nn, 1, 3) = 0.0_8
        call popreal8(matrixcoefspectral(mm, nn, 1, 2))
        matrixcoefspectrald(mm, nn, 1, 2) = 0.0_8
        call popreal8(matrixcoefspectral(mm, nn, 1, 1))
        matrixcoefspectrald(mm, nn, 1, 1) = 0.0_8
        call popreal8(coef)
        call popreal8(angle)
      end do
      coefd = 0.0_8
      do nn=ntimeintervalsspectral-1,1,-1
        coefd = -coefd
        call popcontrol1b(branch)
        if (branch .eq. 0) coefspectrald(mm, nn) = cos(angle)*&
&           coefspectrald(mm, nn)
        coefd = coefd + coefspectrald(mm, nn)/sin(angle)
        coefspectrald(mm, nn) = 0.0_8
        call popreal8(angle)
      end do
      tempd = pi*coefd/sections(mm)%timeperiod
      timerefd = timerefd + tempd
      sectionsd(mm)%timeperiod = sectionsd(mm)%timeperiod - timeref*&
&       tempd/sections(mm)%timeperiod
    end do
  end subroutine timespectralcoef_b
  subroutine timespectralmatrices()
!
!       timespectralmatrices computes the matrices for the time
!       derivative of the time spectral method for all sections. for
!       scalar quantities these matrices only differ if sections have
!       different periodic times. for vector quantities, such as
!       momentum, these matrices can be different depending on whether
!       the section is rotating or not and the number of slices
!       present.
!
    use constants
    use inputphysics, only : equationmode
    use inputtimespectral, only : ntimeintervalsspectral, &
&   rotmatrixspectral, coefspectral, matrixcoefspectral, &
&   diagmatcoefspectral, dscalar, dvector
    use section, only : nsections
    use utils_b, only : terminate
    implicit none
!
!      local variables.
!
    integer :: ierr
    integer(kind=inttype) :: nn, mm, ll, kk, ii
    integer(kind=inttype) :: i, j
    real(kind=realtype), dimension(3, 3) :: tmpmat
! this routine is only used for the spectral solutions. return
! immediately if a different mode is solved.
    if (equationmode .ne. timespectral) then
      return
    else
! determine the help variables needed to construct the
! actual matrices.
      call timespectralcoef()
!
!       determine the time derivative matrices for the sections.
!
! loop over the number of sections.
sectionloop:do ii=1,nsections
!
!         matrix for scalar quantities.
!
! loop over the number of rows.
        do nn=1,ntimeintervalsspectral
! set the diagonal element to zero, i.e. there is no
! contribution to the own time derivative.
          dscalar(ii, nn, nn) = zero
! loop over the rest of the columns.
          do mm=1,ntimeintervalsspectral-1
! determine the corresponding column index.
            ll = nn + mm
            if (ll .gt. ntimeintervalsspectral) ll = ll - &
&               ntimeintervalsspectral
! store the corresponding coefficient in dscalar.
            dscalar(ii, nn, ll) = coefspectral(ii, mm)
          end do
        end do
!
!         matrices for vector quantities.
!
! loop over the number of time intervals; the number of rows
! is 3 times this number.
rowloop:do nn=1,ntimeintervalsspectral
! initialize the diagonal block to diagmatcoefspectral,
! the additional diagonal entry needed for the rotational
! periodicity.
          kk = 3*(nn-1)
          do j=1,3
            do i=1,3
              dvector(ii, kk+i, kk+j) = diagmatcoefspectral(ii, i, j)
            end do
          end do
! loop over the other time intervals, which contribute to
! the time derivative.
columnloop:do mm=1,ntimeintervalsspectral-1
! determine the corresponding column index and check the
! situation we are having here.
            ll = nn + mm
            if (ll .gt. ntimeintervalsspectral) then
! index is outside the range and a shift must be applied.
              ll = ll - ntimeintervalsspectral
! the vector must be rotated. this effect is incorporated
! directly in the matrix of time derivatives.
              do j=1,3
                do i=1,3
                  tmpmat(i, j) = matrixcoefspectral(ii, mm, i, 1)*&
&                   rotmatrixspectral(ii, 1, j) + matrixcoefspectral(ii&
&                   , mm, i, 2)*rotmatrixspectral(ii, 2, j) + &
&                   matrixcoefspectral(ii, mm, i, 3)*rotmatrixspectral(&
&                   ii, 3, j)
                end do
              end do
            else
! index is in the range. copy the matrix coefficient
! into tmpmat.
              do j=1,3
                do i=1,3
                  tmpmat(i, j) = matrixcoefspectral(ii, mm, i, j)
                end do
              end do
            end if
! determine the offset for the column index and store
! this submatrix in the correct place of dvector.
            ll = 3*(ll-1)
            do j=1,3
              do i=1,3
                dvector(ii, kk+i, ll+j) = tmpmat(i, j)
              end do
            end do
          end do columnloop
        end do rowloop
      end do sectionloop
    end if
  end subroutine timespectralmatrices
  subroutine timespectralcoef()
!
!       timespectralcoef computes the time integration coefficients
!       for the time spectral method. as it is possible that sections
!       have different periodic times these coefficients are
!       determined for all the sections. for vector quantities, such
!       as momentum, these coefficients can also be different due to
!       rotation and the fact that only a part of the wheel is
!       simulated.
!
    use constants
    use flowvarrefstate, only : timeref
    use inputtimespectral, only : ntimeintervalsspectral, &
&   rotmatrixspectral, coefspectral, matrixcoefspectral, &
&   diagmatcoefspectral
    use section, only : nsections, sections
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: pp, nn, mm, ii, i, j, ntot
    real(kind=realtype) :: coef, dangle, angle, fact, slicesfact
    real(kind=realtype), dimension(3, 3) :: rotmat, tmp
    intrinsic real
    intrinsic sin
    intrinsic mod
    intrinsic cos
! loop over the number of sections.
sectionloop:do mm=1,nsections
! initialize dangle (smallest angle in the cotangent function)
! and coef, which is the multiplication factor in front of the
! cotangent/cosecant function. coef is a combination of the 1/2
! and the 2*pi/timeperiod
      dangle = pi/real(ntimeintervalsspectral, realtype)
      coef = pi*timeref/sections(mm)%timeperiod
! computation of the scalar coefficients.
scalarloop:do nn=1,ntimeintervalsspectral-1
        angle = nn*dangle
! the coefficient for an odd and even number of time
! instances are different; the former is 1/sin, the
! latter cos/sin or 1/tan.
        coefspectral(mm, nn) = coef/sin(angle)
        if (mod(ntimeintervalsspectral, 2_inttype) .eq. 0) coefspectral(&
&         mm, nn) = coefspectral(mm, nn)*cos(angle)
! negate coef for the next spectral coefficient.
        coef = -coef
      end do scalarloop
! initialize dangle to the smallest angle in the cotangent
! or cosecant function. now this angle is for the entire wheel,
! i.e. the number of slices must be taken into account.
      ntot = ntimeintervalsspectral*sections(mm)%nslices
      dangle = pi/real(ntot, realtype)
! initialize the rotation matrix to the unity matrix.
      rotmat(1, 1) = one
      rotmat(1, 2) = zero
      rotmat(1, 3) = zero
      rotmat(2, 1) = zero
      rotmat(2, 2) = one
      rotmat(2, 3) = zero
      rotmat(3, 1) = zero
      rotmat(3, 2) = zero
      rotmat(3, 3) = one
! loop over the number of spectral coefficient to initialize the
! matrix coefficients; this is basically pp == 0 in the loop
! over the number slices. use is made of the fact that the
! rotation matrix is the identity for pp == 0.
! coef changes sign at every time instance
      slicesfact = one/real(sections(mm)%nslices, realtype)
      fact = one
      do nn=1,ntimeintervalsspectral-1
! determine the scalar coefficient. this value depends now
! whether the total number of time instances in the wheel is
! odd or even.
        angle = nn*dangle
        coef = one/sin(angle)
        if (mod(ntot, 2_inttype) .eq. 0) coef = coef*cos(angle)
        coef = coef*fact*slicesfact
! the first part of matrixcoefspectral is a diagonal matrix,
! because this indicates the contribution of the current
! slice to the time derivative.
        matrixcoefspectral(mm, nn, 1, 1) = coef
        matrixcoefspectral(mm, nn, 1, 2) = zero
        matrixcoefspectral(mm, nn, 1, 3) = zero
        matrixcoefspectral(mm, nn, 2, 1) = zero
        matrixcoefspectral(mm, nn, 2, 2) = coef
        matrixcoefspectral(mm, nn, 2, 3) = zero
        matrixcoefspectral(mm, nn, 3, 1) = zero
        matrixcoefspectral(mm, nn, 3, 2) = zero
        matrixcoefspectral(mm, nn, 3, 3) = coef
        fact = -fact
      end do
! initialize diagmatcoefspectral to zero, because the
! starting index in the loop over the number of slices -1 is
! 1, i.e. the slice where the actual computation takes places
! does not contribute to diagmatcoefspectral.
      do j=1,3
        do i=1,3
          diagmatcoefspectral(mm, i, j) = zero
        end do
      end do
! loop over the additional slices which complete an entire
! revolution. to be able to compute the coefficients a bit
! easier the loop runs from 1 to nslices-1 and not from
! 2 to nslices.
slicesloop:do pp=1,sections(mm)%nslices-1
! compute the rotation matrix for this slice. this is the
! old one multiplied by the transformation matrix going from
! one slices to the next. use tmp as temporary storage.
        do j=1,3
          do i=1,3
            tmp(i, j) = rotmatrixspectral(mm, i, 1)*rotmat(1, j) + &
&             rotmatrixspectral(mm, i, 2)*rotmat(2, j) + &
&             rotmatrixspectral(mm, i, 3)*rotmat(3, j)
          end do
        end do
        rotmat = tmp
        slicesfact = one/real(sections(mm)%nslices, realtype)
! loop over the number of spectral coefficients and update
! matrixcoefspectral. the multiplication with (-1)**nn
! takes place here too.
! multiply also by the term (-1)**(pn+1)
        fact = one
        if (mod(pp*ntimeintervalsspectral, 2_inttype) .ne. 0) fact = -&
&           one
        slicesfact = fact*slicesfact
        fact = one
        ii = pp*ntimeintervalsspectral
        do nn=1,ntimeintervalsspectral-1
! compute the coefficient multiplying the rotation matrix.
! again make a distinction between an odd and an even
! number of time instances for the entire wheel.
          angle = (nn+ii)*dangle
          coef = one/sin(angle)
          if (mod(ntot, 2_inttype) .eq. 0) coef = coef*cos(angle)
          coef = coef*fact*slicesfact
! update matrixcoefspectral.
          do j=1,3
            do i=1,3
              matrixcoefspectral(mm, nn, i, j) = matrixcoefspectral(mm, &
&               nn, i, j) + coef*rotmat(i, j)
            end do
          end do
          fact = -fact
        end do
! update diagmatcoefspectral. also here the distinction
! between odd and even number of time instances.
        angle = ii*dangle
        coef = one/sin(angle)
        if (mod(ntot, 2_inttype) .eq. 0) coef = coef*cos(angle)
        coef = coef*slicesfact
        do j=1,3
          do i=1,3
            diagmatcoefspectral(mm, i, j) = diagmatcoefspectral(mm, i, j&
&             ) - coef*rotmat(i, j)
          end do
        end do
      end do slicesloop
! the matrix coefficients must be multiplied by the leading
! coefficient, which depends on the actual periodic time.
      coef = pi*timeref/sections(mm)%timeperiod
      do j=1,3
        do i=1,3
          diagmatcoefspectral(mm, i, j) = coef*diagmatcoefspectral(mm, i&
&           , j)
        end do
      end do
      do nn=1,ntimeintervalsspectral-1
        do j=1,3
          do i=1,3
            matrixcoefspectral(mm, nn, i, j) = coef*matrixcoefspectral(&
&             mm, nn, i, j)
          end do
        end do
      end do
    end do sectionloop
  end subroutine timespectralcoef
end module initializeflow_b
