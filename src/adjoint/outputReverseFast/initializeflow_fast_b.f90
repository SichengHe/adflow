!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module initializeflow_fast_b
  use constants, only : inttype, realtype, maxstringlen
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------
  save 

contains
  subroutine referencestate()
!
!       the original version has been nuked since the computations are
!       no longer necessary when calling from python
!       this is the most compliclated routine in all of adflow. it is
!       stupidly complicated. this is most likely the reason your
!       derivatives are wrong. you don't understand this routine
!       and its effects.
!       this routine *requries* the following as input:
!       mach, pinfdim, tinfdim, rhoinfdim, rgasdim (machcoef non-sa
!        turbulence only)
!       optionally, pref, rhoref and tref are used if they are
!       are non-negative. this only happens when you want the equations
!       normalized by values other than the freestream
!      * this routine computes as output:
!      *   muinfdim, (unused anywhere in code)
!         pref, rhoref, tref, muref, timeref ('dimensional' reference)
!         pinf, pinfcorr, rhoinf, uinf, rgas, muinf, gammainf and winf
!         (non-dimensionalized values used in actual computations)
!
    use constants
    use paramturb
    use inputphysics, only : equations, mach, machcoef, musuthdim, &
&   tsuthdim, veldirfreestream, rgasdim, ssuthdim, eddyvisinfratio, &
&   turbmodel, turbintensityinf
    use flowvarrefstate, only : pinfdim, tinfdim, rhoinfdim, muinfdim,&
&   pref, rhoref, tref, muref, timeref, uref, href, pinf, pinfcorr, &
&   rhoinf, uinf, rgas, muinf, gammainf, winf, nw, nwf, kpresent, winf
    use flowutils_fast_b, only : computegamma, etot
    use turbutils_fast_b, only : sanuknowneddyratio
    implicit none
    integer(kind=inttype) :: sps, nn, mm, ierr
    real(kind=realtype) :: gm1, ratio
    real(kind=realtype) :: nuinf, ktmp, uinf2
    real(kind=realtype) :: vinf, zinf, tmp1(1), tmp2(1)
    intrinsic sqrt
! compute the dimensional viscosity from sutherland's law
    muinfdim = musuthdim*((tsuthdim+ssuthdim)/(tinfdim+ssuthdim))*(&
&     tinfdim/tsuthdim)**1.5_realtype
! set the reference values. they *could* be different from the
! free-stream values for an internal flow simulation. for now,
! we just use the actual free stream values.
    pref = pinfdim
    tref = tinfdim
    rhoref = rhoinfdim
! compute the value of muref, such that the nondimensional
! equations are identical to the dimensional ones.
! note that in the non-dimensionalization of muref there is
! a reference length. however this reference length is 1.0
! in this code, because the coordinates are converted to
! meters.
    muref = sqrt(pref*rhoref)
! compute timeref for a correct nondimensionalization of the
! unsteady equations. some story as for the reference viscosity
! concerning the reference length.
    timeref = sqrt(rhoref/pref)
    href = pref/rhoref
    uref = sqrt(href)
! compute the nondimensional pressure, density, velocity,
! viscosity and gas constant.
    pinf = pinfdim/pref
    rhoinf = rhoinfdim/rhoref
    uinf = mach*sqrt(gammainf*pinf/rhoinf)
    rgas = rgasdim*rhoref*tref/pref
    muinf = muinfdim/muref
    tmp1(1) = tinfdim
    call computegamma(tmp1, tmp2, 1)
    gammainf = tmp2(1)
! ----------------------------------------
!      compute the final winf
! ----------------------------------------
! allocate the memory for winf if necessary
! zero out the winf first
    winf(:) = zero
! set the reference value of the flow variables, except the total
! energy. this will be computed at the end of this routine.
    winf(irho) = rhoinf
    winf(ivx) = uinf*veldirfreestream(1)
    winf(ivy) = uinf*veldirfreestream(2)
    winf(ivz) = uinf*veldirfreestream(3)
! compute the velocity squared based on machcoef. this gives a
! better indication of the 'speed' of the flow so the turubulence
! intensity ration is more meaningful especially for moving
! geometries. (not used in sa model)
    uinf2 = machcoef*machcoef*gammainf*pinf/rhoinf
! set the turbulent variables if transport variables are to be
! solved. we should be checking for rans equations here,
! however, this code is included in block res. the issue is
! that for frozen turbulence (or ank jacobian) we call the
! block_res with equationtype set to laminar even though we are
! actually solving the rans equations. the issue is that, the
! freestream turb variables will be changed to zero, thus
! changing the solution. insteady we check if nw > nwf which
! will accomplish the same thing.
    if (nw .gt. nwf) then
      nuinf = muinf/rhoinf
      select case  (turbmodel) 
      case (spalartallmaras, spalartallmarasedwards) 
        winf(itu1) = sanuknowneddyratio(eddyvisinfratio, nuinf)
      case (komegawilcox, komegamodified, mentersst) 
!=============================================================
        winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
        winf(itu2) = winf(itu1)/(eddyvisinfratio*nuinf)
      case (ktau) 
!=============================================================
        winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
        winf(itu2) = eddyvisinfratio*nuinf/winf(itu1)
      case (v2f) 
!=============================================================
        winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
        winf(itu2) = 0.09_realtype*winf(itu1)**2/(eddyvisinfratio*nuinf)
        winf(itu3) = 0.666666_realtype*winf(itu1)
        winf(itu4) = 0.0_realtype
      end select
    end if
! set the value of pinfcorr. in case a k-equation is present
! add 2/3 times rho*k.
    pinfcorr = pinf
    if (kpresent) pinfcorr = pinf + two*third*rhoinf*winf(itu1)
! compute the free stream total energy.
    ktmp = zero
    if (kpresent) ktmp = winf(itu1)
    vinf = zero
    zinf = zero
    call etot(rhoinf, uinf, vinf, zinf, pinfcorr, ktmp, winf(irhoe), &
&       kpresent)
  end subroutine referencestate
  subroutine timespectralmatrices()
!
!       timespectralmatrices computes the matrices for the time
!       derivative of the time spectral method for all sections. for
!       scalar quantities these matrices only differ if sections have
!       different periodic times. for vector quantities, such as
!       momentum, these matrices can be different depending on whether
!       the section is rotating or not and the number of slices
!       present.
!
    use constants
    use inputphysics, only : equationmode
    use inputtimespectral, only : ntimeintervalsspectral, &
&   rotmatrixspectral, coefspectral, matrixcoefspectral, &
&   diagmatcoefspectral, dscalar, dvector
    use section, only : nsections
    use utils_fast_b, only : terminate
    implicit none
!
!      local variables.
!
    integer :: ierr
    integer(kind=inttype) :: nn, mm, ll, kk, ii
    integer(kind=inttype) :: i, j
    real(kind=realtype), dimension(3, 3) :: tmpmat
! this routine is only used for the spectral solutions. return
! immediately if a different mode is solved.
    if (equationmode .ne. timespectral) then
      return
    else
! determine the help variables needed to construct the
! actual matrices.
      call timespectralcoef()
!
!       determine the time derivative matrices for the sections.
!
! loop over the number of sections.
sectionloop:do ii=1,nsections
!
!         matrix for scalar quantities.
!
! loop over the number of rows.
        do nn=1,ntimeintervalsspectral
! set the diagonal element to zero, i.e. there is no
! contribution to the own time derivative.
          dscalar(ii, nn, nn) = zero
! loop over the rest of the columns.
          do mm=1,ntimeintervalsspectral-1
! determine the corresponding column index.
            ll = nn + mm
            if (ll .gt. ntimeintervalsspectral) ll = ll - &
&               ntimeintervalsspectral
! store the corresponding coefficient in dscalar.
            dscalar(ii, nn, ll) = coefspectral(ii, mm)
          end do
        end do
!
!         matrices for vector quantities.
!
! loop over the number of time intervals; the number of rows
! is 3 times this number.
rowloop:do nn=1,ntimeintervalsspectral
! initialize the diagonal block to diagmatcoefspectral,
! the additional diagonal entry needed for the rotational
! periodicity.
          kk = 3*(nn-1)
          do j=1,3
            do i=1,3
              dvector(ii, kk+i, kk+j) = diagmatcoefspectral(ii, i, j)
            end do
          end do
! loop over the other time intervals, which contribute to
! the time derivative.
columnloop:do mm=1,ntimeintervalsspectral-1
! determine the corresponding column index and check the
! situation we are having here.
            ll = nn + mm
            if (ll .gt. ntimeintervalsspectral) then
! index is outside the range and a shift must be applied.
              ll = ll - ntimeintervalsspectral
! the vector must be rotated. this effect is incorporated
! directly in the matrix of time derivatives.
              do j=1,3
                do i=1,3
                  tmpmat(i, j) = matrixcoefspectral(ii, mm, i, 1)*&
&                   rotmatrixspectral(ii, 1, j) + matrixcoefspectral(ii&
&                   , mm, i, 2)*rotmatrixspectral(ii, 2, j) + &
&                   matrixcoefspectral(ii, mm, i, 3)*rotmatrixspectral(&
&                   ii, 3, j)
                end do
              end do
            else
! index is in the range. copy the matrix coefficient
! into tmpmat.
              do j=1,3
                do i=1,3
                  tmpmat(i, j) = matrixcoefspectral(ii, mm, i, j)
                end do
              end do
            end if
! determine the offset for the column index and store
! this submatrix in the correct place of dvector.
            ll = 3*(ll-1)
            do j=1,3
              do i=1,3
                dvector(ii, kk+i, ll+j) = tmpmat(i, j)
              end do
            end do
          end do columnloop
        end do rowloop
      end do sectionloop
    end if
  end subroutine timespectralmatrices
  subroutine timespectralcoef()
!
!       timespectralcoef computes the time integration coefficients
!       for the time spectral method. as it is possible that sections
!       have different periodic times these coefficients are
!       determined for all the sections. for vector quantities, such
!       as momentum, these coefficients can also be different due to
!       rotation and the fact that only a part of the wheel is
!       simulated.
!
    use constants
    use flowvarrefstate, only : timeref
    use inputtimespectral, only : ntimeintervalsspectral, &
&   rotmatrixspectral, coefspectral, matrixcoefspectral, &
&   diagmatcoefspectral
    use section, only : nsections, sections
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: pp, nn, mm, ii, i, j, ntot
    real(kind=realtype) :: coef, dangle, angle, fact, slicesfact
    real(kind=realtype), dimension(3, 3) :: rotmat, tmp
    intrinsic real
    intrinsic sin
    intrinsic mod
    intrinsic cos
! loop over the number of sections.
sectionloop:do mm=1,nsections
! initialize dangle (smallest angle in the cotangent function)
! and coef, which is the multiplication factor in front of the
! cotangent/cosecant function. coef is a combination of the 1/2
! and the 2*pi/timeperiod
      dangle = pi/real(ntimeintervalsspectral, realtype)
      coef = pi*timeref/sections(mm)%timeperiod
! computation of the scalar coefficients.
scalarloop:do nn=1,ntimeintervalsspectral-1
        angle = nn*dangle
! the coefficient for an odd and even number of time
! instances are different; the former is 1/sin, the
! latter cos/sin or 1/tan.
        coefspectral(mm, nn) = coef/sin(angle)
        if (mod(ntimeintervalsspectral, 2_inttype) .eq. 0) coefspectral(&
&         mm, nn) = coefspectral(mm, nn)*cos(angle)
! negate coef for the next spectral coefficient.
        coef = -coef
      end do scalarloop
! initialize dangle to the smallest angle in the cotangent
! or cosecant function. now this angle is for the entire wheel,
! i.e. the number of slices must be taken into account.
      ntot = ntimeintervalsspectral*sections(mm)%nslices
      dangle = pi/real(ntot, realtype)
! initialize the rotation matrix to the unity matrix.
      rotmat(1, 1) = one
      rotmat(1, 2) = zero
      rotmat(1, 3) = zero
      rotmat(2, 1) = zero
      rotmat(2, 2) = one
      rotmat(2, 3) = zero
      rotmat(3, 1) = zero
      rotmat(3, 2) = zero
      rotmat(3, 3) = one
! loop over the number of spectral coefficient to initialize the
! matrix coefficients; this is basically pp == 0 in the loop
! over the number slices. use is made of the fact that the
! rotation matrix is the identity for pp == 0.
! coef changes sign at every time instance
      slicesfact = one/real(sections(mm)%nslices, realtype)
      fact = one
      do nn=1,ntimeintervalsspectral-1
! determine the scalar coefficient. this value depends now
! whether the total number of time instances in the wheel is
! odd or even.
        angle = nn*dangle
        coef = one/sin(angle)
        if (mod(ntot, 2_inttype) .eq. 0) coef = coef*cos(angle)
        coef = coef*fact*slicesfact
! the first part of matrixcoefspectral is a diagonal matrix,
! because this indicates the contribution of the current
! slice to the time derivative.
        matrixcoefspectral(mm, nn, 1, 1) = coef
        matrixcoefspectral(mm, nn, 1, 2) = zero
        matrixcoefspectral(mm, nn, 1, 3) = zero
        matrixcoefspectral(mm, nn, 2, 1) = zero
        matrixcoefspectral(mm, nn, 2, 2) = coef
        matrixcoefspectral(mm, nn, 2, 3) = zero
        matrixcoefspectral(mm, nn, 3, 1) = zero
        matrixcoefspectral(mm, nn, 3, 2) = zero
        matrixcoefspectral(mm, nn, 3, 3) = coef
        fact = -fact
      end do
! initialize diagmatcoefspectral to zero, because the
! starting index in the loop over the number of slices -1 is
! 1, i.e. the slice where the actual computation takes places
! does not contribute to diagmatcoefspectral.
      do j=1,3
        do i=1,3
          diagmatcoefspectral(mm, i, j) = zero
        end do
      end do
! loop over the additional slices which complete an entire
! revolution. to be able to compute the coefficients a bit
! easier the loop runs from 1 to nslices-1 and not from
! 2 to nslices.
slicesloop:do pp=1,sections(mm)%nslices-1
! compute the rotation matrix for this slice. this is the
! old one multiplied by the transformation matrix going from
! one slices to the next. use tmp as temporary storage.
        do j=1,3
          do i=1,3
            tmp(i, j) = rotmatrixspectral(mm, i, 1)*rotmat(1, j) + &
&             rotmatrixspectral(mm, i, 2)*rotmat(2, j) + &
&             rotmatrixspectral(mm, i, 3)*rotmat(3, j)
          end do
        end do
        rotmat = tmp
        slicesfact = one/real(sections(mm)%nslices, realtype)
! loop over the number of spectral coefficients and update
! matrixcoefspectral. the multiplication with (-1)**nn
! takes place here too.
! multiply also by the term (-1)**(pn+1)
        fact = one
        if (mod(pp*ntimeintervalsspectral, 2_inttype) .ne. 0) fact = -&
&           one
        slicesfact = fact*slicesfact
        fact = one
        ii = pp*ntimeintervalsspectral
        do nn=1,ntimeintervalsspectral-1
! compute the coefficient multiplying the rotation matrix.
! again make a distinction between an odd and an even
! number of time instances for the entire wheel.
          angle = (nn+ii)*dangle
          coef = one/sin(angle)
          if (mod(ntot, 2_inttype) .eq. 0) coef = coef*cos(angle)
          coef = coef*fact*slicesfact
! update matrixcoefspectral.
          do j=1,3
            do i=1,3
              matrixcoefspectral(mm, nn, i, j) = matrixcoefspectral(mm, &
&               nn, i, j) + coef*rotmat(i, j)
            end do
          end do
          fact = -fact
        end do
! update diagmatcoefspectral. also here the distinction
! between odd and even number of time instances.
        angle = ii*dangle
        coef = one/sin(angle)
        if (mod(ntot, 2_inttype) .eq. 0) coef = coef*cos(angle)
        coef = coef*slicesfact
        do j=1,3
          do i=1,3
            diagmatcoefspectral(mm, i, j) = diagmatcoefspectral(mm, i, j&
&             ) - coef*rotmat(i, j)
          end do
        end do
      end do slicesloop
! the matrix coefficients must be multiplied by the leading
! coefficient, which depends on the actual periodic time.
      coef = pi*timeref/sections(mm)%timeperiod
      do j=1,3
        do i=1,3
          diagmatcoefspectral(mm, i, j) = coef*diagmatcoefspectral(mm, i&
&           , j)
        end do
      end do
      do nn=1,ntimeintervalsspectral-1
        do j=1,3
          do i=1,3
            matrixcoefspectral(mm, nn, i, j) = coef*matrixcoefspectral(&
&             mm, nn, i, j)
          end do
        end do
      end do
    end do sectionloop
  end subroutine timespectralcoef
end module initializeflow_fast_b
